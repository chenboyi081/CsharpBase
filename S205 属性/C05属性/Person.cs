using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace C05属性
{
    class Person
    {
        public double Height { get; set; }

        public void Test()
        {
            this.Height = 12.12; 
        }


        public string Name { get; set; }  

        private int age;
        public int Age
        {
            get
            {
                return this.age;
            }
            set
            {
                this.age = value >= 0 && value <= 100 ? value : 19;            
            }
        }

        /* 1. 属性和我们之前学的Get和Set方法一样,也是用来保护字段的.
         *    只不过属性的这中写法会比方法要简洁.
         *    
         * 2. 语法:
         *    访问修饰符 属性的类型 属性的名称
         *    {
         *        get
         *        {
         *        
         *        }
         *        set
         *        {
         *        
         *        }
         *    }
         *    
         * 3. 操作属性可以像操作字段那样.直接的为这个属性赋值或者取值.
         * 
         * 4. 属性如何保护字段的?
         *    a. 当我们为属性赋值的时候.就会执行属性中的set代码块中的内容.
         *    b. 在set块中 通过value关键字 可以取到用户为属性赋的值.
         *       在其中,我们就可以对value做逻辑验证,如果符合就赋值 否则默认处理.
         *    
         *    c. 当我们取属性的值的时候,就会执行这个属性中的get代码块.
         *       取出来的值, 是在get后return回去的值 。
         * 
         * 
         * 5. 注意:
         *    a. 属性是用来保护字段的,所以首先是得有1个被保护的字段.
         *    b. 被保护的字段一定要私有化.
         *    c. 属性的访问修饰符. 希望属性可以在什么地方访问就写什么修饰符.
         *       只不过一般情况下,都是public
         *    d. 属性的类型绝大多数情况下和被保护的字段的类型保持一致.
         *    e. 属性的名称其实是可以随意定义的. 每个单词的首字母大写.
         *       但是建议:属性的名称和它保护的字段的名称保持一致.只做大小写的区分.
         *       这样方便代码的阅读.
         *    f. set块中的代码在为属性赋值的时候执行.
         *       在set块里面可以通过value关键字取到用户为属性赋的值
         *       set块中的代码只要符合C#的语法规范都可以写. 
         *       但是一般情况下我们在其中写逻辑验证的代码.
         *    g. 为属性赋值的时候,赋的值的类型要和属性的类型一致,与被保护的字段的类型毫无关系.
         *       属性的类型决定了 为属性赋的值的类型
         *       同时也决定了set块中的 value的 类型.
         *    h. get块 在取属性的值的时候自动执行.
         *       最终取到的值 是 return回去的值. 
         *       在get块结束之前,必须要return回去1个和属性的类型相同的数据,
         *       只不过一般情况下我们return回去的是被保护的字段的值.
         *      
         * 6. 在属性中记住操作的是被保护的字段,而不是属性自己.否则就会发生死循环.    
         * 
         * 7. 属性的本质其实是方法.
         *    根据我们反编译的结果:
         *    我们发现,C#编译器会自动的为属性生成1个get方法和1个set方法. 这两个方法的作用仍然是用来为字段赋值和取值的.
         *    只不过我们写在属性set中的代码 被放在了set方法中. 这个方法的参数是value. 所以我们可以在set块中直接使用value的值.
         *    我们写在get块中的代码 被放在了get方法中.
         *    
         *    所以我们写在get和set中的代码,其实是放在方法中的.
         * 
         * 
         * 8. 属性本身存不了值的,属性取到用户赋的值以后,再将这个值转存给字段.
         *    中间人.
         *    
         * 
         * 9. 快速封装字段: ctrl+r+e
         * 
         * 
         * 10.规范:只要字段需要被外界访问,无论在取值或者赋值的时候需不需要做逻辑验证
         *         我们都要为这个字段封装属性.
         * 
         * 
         * 
         * 11.只写属性: 属性中只有set没有get. 那么只能为这个属性赋值,而不能取这个属性的值.
         *    只读属性: 属性中只有get没有set，那么只能为这个属性取值,而不能为这个属性赋值,
         *    属性中至少要保留1个访问器.
         *    
         * 
         * 12.自动属性
         *    如果1个字段的赋值和取值没有任何逻辑验证.并且可读可写.
         *    这个时候,我们就可以不声明字段.
         *    public string Name { get; set; } 
         *    
         *    当我们写1个自动属性的时候,C#编译器在编译的时候会自动的生成1个字段.这个字段的名称叫做<自动属性的名称>k_backingFiled
         *    这个字段被自动属性所封装.
         *    只不过在get和set的时候没有做任何的逻辑验证.
         *    
         *    什么时候可以写自动属性?
         *    a. 对字段的赋值和取值没有任何逻辑验证.
         *    b. 可读并且可写.
         *    
         *    
         * 
         * 
         */
    }
}
